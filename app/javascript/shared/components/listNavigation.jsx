import PropTypes from 'prop-types';
import { isInViewport } from '../../utilities/viewport';
import { useGlobalKeyEventListener } from './keyEventListener';

const NAVIGATION_UP_KEY = 'k';
const NAVIGATION_DOWN_KEY = 'j';

const DIRECTIONS = {
  UP: 'up',
  DOWN: 'down',
};

/**
 * Calls a hook that registers global key event listeners for 'j' and 'k' to navigate up and down in a list of items
 *
 * @example
 * <ListNavigation
 *   itemContainerSelector=".crayons-story"
 *   focusableSelector="a[id^=article-link-]"
 *   waterfallItemContainerSelector="div.paged-stories,div.substories"
 * />
 *
 * Note:
 * To avoid conflicts, only one of these should be called per page.
 * The hook automatically unregisters the event listener when the component is unmounted.
 *
 * Note on waterfalls:
 * In the next example, the waterfall container would be 'div.paged-stories':
 * <article />
 * <article />
 * <div class="paged-stories">
 *   <!-- level 1 -->
 *   <article />
 *   <article />
 *   <div class="paged-stories">
 *     <!-- level 2 -->
 *     <article />
 *     <article />
 *   </div>
 * </div>
 */
export function ListNavigation({
  itemContainerSelector,
  focusableSelector,
  waterfallItemContainerSelector,
}) {
  useGlobalKeyEventListener([NAVIGATION_UP_KEY, NAVIGATION_DOWN_KEY], function (
    event,
  ) {
    keyEventListener(
      event,
      itemContainerSelector,
      focusableSelector,
      waterfallItemContainerSelector,
    );
  });

  return null;
}

ListNavigation.propTypes = {
  itemContainerSelector: PropTypes.string.isRequired,
  focusableSelector: PropTypes.string.isRequired,
  waterfallItemContainerSelector: PropTypes.string,
};

/**
 * Focuses on the next/previous element depending on the navigation direction
 *
 * @param {object} event - The KeyboardEvent generated by the 'keydown' event
 * @param {object} element - The current element
 * @param {string} itemContainerSelector - The selector for the highest level container of an item
 * @param {string} waterfallItemContainerSelector - The selector for the waterfall item container if the list uses a waterfall structure at any point
 */
function keyEventListener(
  event,
  itemContainerSelector,
  focusableSelector,
  waterfallItemContainerSelector,
) {
  const direction =
    event.key === NAVIGATION_UP_KEY ? DIRECTIONS.UP : DIRECTIONS.DOWN;

  const closestContainer = document.activeElement?.closest(
    itemContainerSelector,
  );

  let nextContainer;
  if (!closestContainer) {
    nextContainer = getFirstVisibleElement(itemContainerSelector);
  }
  if (!nextContainer) {
    nextContainer =
      direction === DIRECTIONS.UP
        ? getPreviousElement(
            closestContainer,
            itemContainerSelector,
            waterfallItemContainerSelector,
          )
        : getNextElement(
            closestContainer,
            itemContainerSelector,
            waterfallItemContainerSelector,
          );
  }

  const nextFocusable = nextContainer?.querySelector(focusableSelector);
  if (nextFocusable) {
    nextFocusable.focus();
  }
}

/**
 * Gets the next element of a list that matches a selector
 *
 * @param {object} element - The current element
 * @param {string} itemContainerSelector - The selector for the highest level container of an item
 * @param {string} waterfallItemContainerSelector - The selector for the waterfall item container if the list uses a waterfall structure at any point
 */
function getNextElement(
  element,
  itemContainerSelector,
  waterfallItemContainerSelector,
) {
  const sibling = element?.nextElementSibling;
  if (
    sibling &&
    !sibling.matches(
      `${itemContainerSelector},${waterfallItemContainerSelector}`,
    )
  ) {
    return sibling.nextElementSibling;
  }
  return sibling;
}

/**
 * Gets the previous element of a list that matches a selector
 *
 * @param {object} element - The current element
 * @param {string} itemContainerSelector - The selector for the highest level container of an item
 * @param {string} waterfallItemContainerSelector - The selector for the waterfall item container if the list uses a waterfall structure at any point
 */
function getPreviousElement(
  element,
  itemContainerSelector,
  waterfallItemContainerSelector,
) {
  if (!element) {
    return null;
  }

  let sibling = element.previousElementSibling;
  if (!sibling && waterfallItemContainerSelector) {
    // reached the top of a waterfall level
    sibling = element.closest(waterfallItemContainerSelector)
      ?.previousElementSibling;
  }

  if (sibling && !sibling.matches(itemContainerSelector)) {
    return sibling.previousElementSibling;
  }

  return sibling;
}

/**
 * Gets the first visible element that matches a selector
 *
 * @param {string} selector - The CSS selector
 */
function getFirstVisibleElement(selector) {
  const elements = document.querySelectorAll(selector);
  return Array.prototype.find.call(elements, isInViewport);
}
