#!/usr/bin/env ruby
require_relative '../config/environment'

require 'fileutils'
require 'openai'
require 'dotenv'
require 'open3'
require 'colorize'

Dotenv.load

# This file requires a token to access GPT-4 and/or gpt-4-32k — it likely only needs to be run by core team members.

def translate(source_of_truth, target_source, target_locale, target_file)
  retries ||= 0 # Initialize a retry counter
  
  puts "Translating from en to #{target_locale} ..., targeting the #{target_file} file".colorize(:light_magenta)
  target_instructions = ""
  messages = []
  system_content = "You are a script that translates text and updates a rails i18n file. Output ONLY the yml for the target file and no additional text text. Please output THE ENTIRE FINISHED TARGET FILE even if you are only changing one key, or even no keys.. Your output should contain exactly the same number of keys as the english input. You are VERY careful about inclusion of special characters, such as : symbols, unescaped ' symbols, etc. which could break yml. These could be present in the current file, and you fix them if they are."
  target_instructions = "Here is the content for the current version of this locale. Only change things that need to be changed:\n\n#{target_source}.\n\n OUTPUT THE ENTIRE FILE for the translation, even if you are only changing one key, or even no keys." if target_source
  user_content = "Translate the following content:\n\n#{source_of_truth}\n\ninto #{target_locale}.yml with all the same keys from the en file.\n\n#{target_instructions} If possible keep the character count similar to the english version. OUTPUT THE ENTIRE TARGET FILE YML WITH ALL KEYS AND NO ADDITIONAL TEXT. Be VERY careful about inclusion of special characters, such as : symbols, unescaped ' symbols, etc. which could break yml. These could be present in the current file, and fix them if they are. Be very conservative in your choices of characters which could break the yml."
  messages << { role: "system", content: system_content }
  messages = [{ role: "user", content: user_content}]
  
  token = ENV["OPENAI_ACCESS_TOKEN"]
  timeout = 480 # 8 minutes for timeout ***plenty of time: Shouldn't legitimately hit this.***
  source_char_count = source_of_truth.size
  model = if source_char_count > 7000
            puts "Large file — switching to gpt-4-32k. This is less efficient, consider refactoring your files to be smaller.".colorize(:red)
            "gpt-4-32k"
          else
            "gpt-4"
          end
  response = OpenAI::Client.new(access_token: token, request_timeout: timeout).chat(
      parameters: {
          model: model, # Required.
          messages: messages, # Required.
          temperature: 0.1,
      })
  output = response.dig("choices", 0, "message", "content")
  puts "Translated! ... #{output[0...20]} ..."
  puts "You now have a new version of the #{target_locale}.yml file!".colorize(:green)
  puts "\n\n"
  output
rescue => e
  retries += 1
  p "Error: #{e.message}"
  puts "Retrying ..."
  retry if retries < 3
end

def read_file_from_last_commit_if_modified(file_path)
  return nil unless File.exist?(file_path)
  # Check if the file has uncommitted changes or is new and untracked
  status, = Open3.capture2e("git status --porcelain #{file_path}")

  if status.start_with?('??')
    puts "Reading file from working copy because it is new and not yet tracked in git"
    content = File.read(file_path)
  elsif status.empty?
    puts "Reading file: #{file_path}"
    # File has no uncommitted changes, read it normally
    content = File.read(file_path)
  else
    puts "Reading file from last commit because it has uncommitted changes which should not be considered."
    puts "If you want to translate the current working copy, commit the changes first."
    # File has uncommitted changes, read the file from the last commit
    begin
      content, = Open3.capture2e("git show HEAD:#{file_path}")
    rescue
      # If the file doesn't exist in the last commit, read the working copy
      content = File.read(file_path)
    end
  end

  content
end

puts "Kicking off translation...."

pattern = 'config/locales/**/en.yml'
last_openai_call_at = 9.seconds.ago # Initial last call time "more than 8 seconds ago" to kick us off.
files = Dir.glob(pattern)
files_finished = []
threads = []
target_locales = ['fr', 'pt']

puts "Let's kick this off!".colorize(:green)
puts "We are about to translate #{files.size * target_locales.size} total locale files.".colorize(:green)

files.each do |file_path|
  source_content = File.read(file_path)

  # using each_slice to create chunks of 5 locales each
  target_locales.each do|locale|
    # Wait up to 8 seconds in order to avoid openai rate limit
    threads << Thread.new(locale) do |locale|
      begin
        target_file = file_path.gsub("en.yml", "#{locale}.yml")
        puts "Starting #{target_file}..."
        target_content = read_file_from_last_commit_if_modified(target_file)
        new_content = translate(source_content, target_content, locale, target_file)
        File.open(target_file, 'w') { |file| file.write(new_content) }
        files_finished << locale
        puts "Finished #{target_file}!!"
        puts "#{files_finished.size} files finished!".colorize(:green)
      rescue => e
        puts "Error: #{e.message}"
      end
    end
  end
end

threads.each(&:join)
